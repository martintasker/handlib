{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 4d09c3e8295b8ea406ec","webpack:///./src/index.js","webpack:///./src/glyph.js","webpack:///./src/glyph-builder.js","webpack:///./src/fx-glyph.js","webpack:///./src/stroke.js","webpack:///./src/bounding-box.js","webpack:///./src/box-transformer.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACNA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;AC/BA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;ACtDA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;ACzKA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,kBAAiB,cAAc;AAC/B;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,cAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA,cAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,mBAAkB,UAAU;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA,kBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;;;;;;;ACvPA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAoD;AACpD,IAAG;AACH,6CAA4C,yCAAyC,sBAAsB;AAC3G,IAAG;AACH,qCAAoC,OAAO,IAAI,UAAU,IAAI;AAC7D,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACrEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA","file":"handlib.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"handlib\"] = factory();\n\telse\n\t\troot[\"handlib\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4d09c3e8295b8ea406ec\n **/","'use strict';\n\nmodule.exports.Glyph = require('./glyph');\nmodule.exports.GlyphBuilder = require('./glyph-builder');\nmodule.exports.FXGlyph = require('./fx-glyph');\nmodule.exports.BoundingBox = require('./bounding-box');\nmodule.exports.BoxTransformer = require('./box-transformer');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0 1\n **/","'use strict';\n\nvar Glyph = function(spec) {\n  this.id = (spec && spec.id) || \"\";\n  this.device = (spec && spec.device) || \"\";\n  this.strokes = (spec && spec.strokes && normalizeStrokes(spec.strokes)) || [];\n  this.scale = spec && spec.scale;\n};\n\nfunction normalizeStrokes(strokesSpec) {\n  return strokesSpec.map(function(strokeSpec) {\n    if (typeof strokeSpec !== 'object') {\n      throw 'bad stroke spec: must be object';\n    }\n    if (typeof strokeSpec[0] === 'number') {\n      var stroke = [];\n      for (var i = 0; i < strokeSpec.length; i += 2) {\n        stroke.push({\n          x: strokeSpec[i],\n          y: strokeSpec[i + 1]\n        });\n      }\n      return stroke;\n    } else if (typeof strokeSpec[0] === 'object') {\n      return strokeSpec;\n    } else {\n      throw 'bad stroke spec: first must be number or (x,y) pair';\n    }\n  });\n}\n\nmodule.exports = Glyph;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/glyph.js\n ** module id = 1\n ** module chunks = 0 1\n **/","'use strict';\n\nvar Glyph = require('./glyph');\n\nvar GlyphBuilder = function() {\n  Glyph.call(this);\n  this.strokeInProgress = false;\n};\n\nGlyphBuilder.prototype = Object.create(Glyph.prototype);\nGlyphBuilder.prototype.constructor = GlyphBuilder;\n\n// implementation -- methods\nGlyphBuilder.prototype.setDevice = function(device) {\n  this.device = device;\n};\n\nGlyphBuilder.prototype.addPoint = function(xy) {\n  var self = this;\n  if (!self.strokeInProgress) {\n    self.strokes.push([]);\n    self.strokeInProgress = true;\n  }\n\n  var stroke = self.strokes[self.strokes.length - 1];\n  if (stroke.length > 0) {\n    var lastPoint = stroke[stroke.length - 1];\n    if (lastPoint.x === xy.x && lastPoint.y === xy.y) {\n      return;\n    }\n  }\n\n  stroke.push(xy);\n};\n\nGlyphBuilder.prototype.endStroke = function() {\n  var self = this;\n  if (!self.strokeInProgress) {\n    return;\n  }\n  var stroke = self.strokes[self.strokes.length - 1];\n  if (stroke.length === 0) {\n    self.strokes.pop();\n  }\n  self.strokeInProgress = false;\n};\n\nGlyphBuilder.prototype.getGlyph = function() {\n  return new Glyph({\n    strokes: this.strokes,\n    device: this.device,\n  });\n};\n\nmodule.exports = GlyphBuilder;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/glyph-builder.js\n ** module id = 2\n ** module chunks = 0 1\n **/","'use strict';\n\n/* jshint jasmine: true */\n\nvar Stroke = require('./stroke');\nvar BoundingBox = require('./bounding-box');\nvar BoxTransformer = require('./box-transformer');\n\nvar FXGlyph = function(glyph) {\n  if (!glyph.scale) {\n    throw 'glyph must have scale for successful feature extraction';\n  }\n  this._glyph = glyph;\n  this._scale = glyph.scale;\n};\n\n// getters\nFXGlyph.prototype = {\n  get glyph() {\n    return this._glyph;\n  },\n  get scale() {\n    return this._scale;\n  },\n  get id() {\n    return this._glyph.id;\n  },\n  get device() {\n    return this._glyph.device;\n  },\n  get bbox() {\n    if (!this._bbox) {\n      this._bbox = this._getBBox(this._glyph);\n    }\n    return this._bbox;\n  },\n  get strokes() {\n    return this._glyph.strokes;\n  },\n  get unitScaledStrokes() {\n    if (!this._unitScaledStrokes) {\n      this._unitScaledStrokes = FXGlyph.getScaledStrokes(this.strokes, this.bbox, new BoundingBox('unit'));\n    }\n    return this._unitScaledStrokes;\n  },\n  get size() {\n    if (!this._sizes) {\n      this._size = this._getSize();\n    }\n    return this._size;\n  },\n  get sizes() {\n    if (!this._sizes) {\n      this._sizes = this._getSizes();\n    }\n    return this._sizes;\n  },\n  get subStrokes() {\n    if (!this._subStrokes) {\n      this._subStrokes = this._getSubStrokes();\n    }\n    return this._subStrokes;\n  },\n  get signature() {\n    if (!this._signature) {\n      this._signature = this._getSignature();\n    }\n    return this._signature;\n  },\n  get featureVector() {\n    if (!this._featureVector) {\n      this._featureVector = this._getFeatureVector();\n    }\n    return this._featureVector;\n  }\n};\n\n// more methods\n\nFXGlyph.prototype._getBBox = function(glyph) {\n  var bboxes = glyph.strokes.map(function(stroke) {\n    return new BoundingBox(stroke);\n  });\n  return new BoundingBox(bboxes);\n};\n\nFXGlyph.getScaledStrokes = function(strokes, bboxFrom, bboxTo) {\n  var scaler = new BoxTransformer(bboxFrom, bboxTo);\n  var scale = Math.min(bboxTo.right - bboxTo.left, bboxTo.bottom - bboxTo.top);\n\n  var oStrokes = strokes.map(function(stroke) {\n    var points = stroke.map(function(xy) {\n      return {\n        x: scaler.x(xy.x),\n        y: scaler.y(xy.y)\n      };\n    });\n    return new Stroke(points, scale);\n  });\n  return oStrokes;\n};\n\nFXGlyph.prototype._getSizes = function() {\n  return this.unitScaledStrokes.map(function(stroke) {\n    return stroke.size;\n  });\n};\n\nFXGlyph.prototype._getSize = function() {\n  return this.sizes.reduce(function(tot, size) {\n    return tot + size;\n  }, 0);\n};\n\nFXGlyph.prototype._getSubStrokes = function() {\n  var allSubStrokes = [];\n  this.unitScaledStrokes.forEach(function(stroke) {\n    var subStrokes = stroke.subStrokes;\n    subStrokes.forEach(function(subStroke) {\n      allSubStrokes.push(subStroke);\n    });\n  });\n  return allSubStrokes;\n};\n\nFXGlyph.prototype._getSignature = function() {\n  return this.subStrokes.map(function(subStroke) {\n      return subStroke.type;\n    })\n    .join(':');\n};\n\nFXGlyph.prototype._getFeatureVector = function() {\n  var fv = [];\n  var ssnf = 1 / Math.sqrt(Stroke.PC_DOT_COUNT);\n  var snf = 1 / Math.sqrt(this.subStrokes.length);\n  this.subStrokes.forEach(function(subStroke) {\n    if (subStroke.type === 'mark') {\n      var pcDot = subStroke.pcDots[0];\n      fv.push(pcDot.x * snf);\n      fv.push(pcDot.y * snf);\n    } else {\n      subStroke.pcDots.forEach(function(pcDot) {\n        fv.push(pcDot.x * snf * ssnf);\n        fv.push(pcDot.y * snf * ssnf);\n      });\n    }\n  });\n  return fv;\n};\n\nFXGlyph.prototype.distanceFrom = function(that) {\n  return FXGlyph.euclideanDistance(this.featureVector, that.featureVector);\n};\n\nFXGlyph.euclideanDistance = function(fv1, fv2) {\n  if (fv1.length !== fv2.length) {\n    throw 'feature vectors must be same length';\n  }\n  var d2 = 0;\n  for (var i = 0; i < fv1.length; ++i) {\n    var d = fv1[i] - fv2[i];\n    d2 += d * d;\n  }\n  return Math.sqrt(d2);\n};\n\n// export\n\nmodule.exports = FXGlyph;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/fx-glyph.js\n ** module id = 3\n ** module chunks = 0 1\n **/","'use strict';\n\nvar Stroke = function(points, scale) {\n  this._points = points;\n  this._scale = scale;\n};\n\nStroke.DS_UNIT_DEFAULT = 0.05;\nStroke.PC_DOT_COUNT = 9;\n\nStroke.getEqualSamples = getEqualSamples;\n\n// getters\nStroke.prototype = {\n  get points() {\n    return this._points;\n  },\n  get scale() {\n    return this._scale;\n  },\n  get size() {\n    if (typeof this._size === 'undefined') {\n      this._size = this._calculateSize();\n    }\n    return this._size;\n  },\n  get ds() {\n    if (typeof this._dS === 'undefined') {\n      this._ds = this._getDS();\n    }\n    return this._ds;\n  },\n  get sList() {\n    if (typeof this._sList === 'undefined') {\n      this._sList = this._getSList();\n    }\n    return this._sList;\n  },\n  get sStroke() {\n    if (typeof this._sStroke === 'undefined') {\n      this._sStroke = this._getSStroke();\n    }\n    return this._sStroke;\n  },\n  get subStrokes() {\n    if (!this._subStrokes) {\n      this._subStrokes = this._getSubStrokes();\n    }\n    return this._subStrokes;\n  },\n};\n\nStroke.prototype._calculateSize = function() {\n  return this.sList[this.points.length - 1];\n};\n\nStroke.prototype._getDS = function() {\n  var ds0 = this.scale * Stroke.DS_UNIT_DEFAULT;\n  var nIncrements = Math.floor(this.size / ds0);\n  var ds = ds0;\n  if (nIncrements > 0) {\n    ds = this.size / nIncrements;\n  }\n  return ds;\n};\n\nStroke.prototype._getSList = function() {\n  var sList = [0];\n  var s = 0;\n  var x = this.points[0].x;\n  var y = this.points[0].y;\n  for (var i = 1; i < this.points.length; i++) {\n    var nx = this.points[i].x;\n    var ny = this.points[i].y;\n    var dx = nx - x;\n    var dy = ny - y;\n    var ds = Math.sqrt(dx * dx + dy * dy);\n    s += ds;\n    sList.push(s);\n    x = nx;\n    y = ny;\n  }\n  return sList;\n};\n\nStroke.prototype._getSStroke = function() {\n  var sList = this.sList;\n  var xList = this.points.map(function(point) {\n    return point.x;\n  });\n  var yList = this.points.map(function(point) {\n    return point.y;\n  });\n  var nSamples = 1 + Math.floor(this.size / this.ds + 0.1);\n  var xs = Stroke.getEqualSamples(xList, sList, nSamples);\n  var ys = Stroke.getEqualSamples(yList, sList, nSamples);\n  var stroke = [];\n  for (var i = 0; i < nSamples; i++) {\n    stroke.push({\n      x: xs[i],\n      y: ys[i]\n    });\n  }\n  return stroke;\n};\n\nStroke.prototype._getSubStrokes = function() {\n  if (this.sStroke.length <= 2) {\n    return [{\n      type: 'mark',\n      stroke: new Stroke([this.points[0]], this.scale),\n      pcDots: [this.points[0]],\n    }];\n  }\n\n  var increments = [];\n  var i;\n  for (i = 1; i < this.sStroke.length; i++) {\n    var dx = this.sStroke[i].x - this.sStroke[i - 1].x;\n    var dy = this.sStroke[i].y - this.sStroke[i - 1].y;\n    increments.push({\n      dx: dx,\n      dy: dy\n    });\n  }\n\n  var breakPoints = [];\n  for (i = 1; i < increments.length; i++) {\n    var i1 = increments[i - 1];\n    var i2 = increments[i];\n    var dot12 = i1.dx * i2.dx + i1.dy * i2.dy;\n    var cosTheta = dot12 / (this.ds * this.ds);\n    if (cosTheta < -0.1) {\n      breakPoints.push(i);\n    }\n  }\n  breakPoints.push(this.sStroke.length - 1);\n\n  var subStrokes = [];\n  var sizes = [];\n\n  function addSubStroke(strokePoints, startIndex, endIndex) {\n    var points = [];\n    for (var i = startIndex; i <= endIndex; i++) {\n      points.push(strokePoints[i]);\n    }\n    subStrokes.push(new Stroke(points, this.scale));\n    sizes.push(this.ds * (endIndex + 1 - startIndex));\n  }\n\n  var startIndex = 0;\n  var breakPointIndex = 0;\n  while (breakPointIndex < breakPoints.length) {\n    var endIndex = breakPoints[breakPointIndex];\n    addSubStroke.call(this, this.sStroke, startIndex, endIndex);\n    startIndex = endIndex;\n    breakPointIndex++;\n  }\n\n  return subStrokes.map(function(subStroke, i) {\n    var start = i === 0;\n    var end = i === subStrokes.length - 1;\n    var type = start && end ? 'stroke' :\n      start && !end ? 'start' :\n      !start && end ? 'end' :\n      'middle';\n    var pcDots = getPCDots(subStroke.points, sizes[i]);\n    return {\n      type: type,\n      stroke: subStroke,\n      pcDots: pcDots,\n    };\n  });\n};\n\nfunction getEqualSamples(xt, st, n) {\n  if (st.length != xt.length) {\n    throw 'st.length must equal xt.length';\n  }\n  if (st[0] !== 0) {\n    throw 'st[0] must be equal to zero';\n  }\n  for (var i = 1; i <= st.length; i++) {\n    if (st[i] < st[i - 1]) {\n      throw 'st must increase monotonically';\n    }\n  }\n  if (n <= 0 || typeof n !== 'number') {\n    throw 'n must be number > 0';\n  }\n  var tmax = xt.length;\n  var smax = st[tmax - 1];\n  var sIncrement = smax / (tmax - 1);\n  var isInLess = 0;\n  var isInMore = 0;\n  var xOut = [];\n  for (var isOut = 0; isOut < n; isOut++) {\n    var s = smax * (isOut / (n - 1));\n    while (st[isInMore] < s && isInMore < st.length - 1) {\n      isInMore += 1;\n    }\n    isInLess = isInMore;\n    while (st[isInLess] > s && isInLess > 0) {\n      isInLess -= 1;\n    }\n    var sLE = st[isInLess];\n    var sGE = st[isInMore];\n    if (sLE === sGE) {\n      xOut.push(xt[isInLess]);\n      continue;\n    }\n    var sRange = sGE - sLE;\n    var xRange = xt[isInMore] - xt[isInLess];\n    var x0 = xt[isInLess];\n    xOut.push(x0 + xRange * (s - sLE) / sRange);\n  }\n  return xOut;\n}\n\nfunction getPCDots(sDots, size) {\n  var xIn = sDots.map(function(dot) {\n    return dot.x;\n  });\n  var yIn = sDots.map(function(dot) {\n    return dot.y;\n  });\n  var nIn = sDots.length;\n  var sIn = [];\n  for (var si = 0; si < nIn; si++) {\n    sIn.push(size * si / (nIn - 1));\n  }\n\n  var xOut = getEqualSamples(xIn, sIn, Stroke.PC_DOT_COUNT);\n  var yOut = getEqualSamples(yIn, sIn, Stroke.PC_DOT_COUNT);\n\n  var pcDots = [];\n  for (var i = 0; i < Stroke.PC_DOT_COUNT; i++) {\n    pcDots.push({\n      x: xOut[i],\n      y: yOut[i]\n    });\n  }\n  return pcDots;\n}\n\n// export\n\nmodule.exports = Stroke;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/stroke.js\n ** module id = 4\n ** module chunks = 0 1\n **/","'use strict';\n\nvar BoundingBox = function(a, b, c, d) {\n  this.top = undefined;\n  this.left = undefined;\n  this.bottom = undefined;\n  this.right = undefined;\n  if (typeof a === 'number' && typeof b === 'number' && typeof c === 'number' && typeof d === 'number') {\n    constructFromCoordinates.call(this, a, b, c, d); // x1, y1, x2, y2\n  } else if (typeof a === 'object' && typeof a.top === 'number') {\n    constructFromList.call(this, arguments); // args are series of BoundingBoxes or {top,left,bottom,right} specs\n  } else if (typeof a === 'object' && typeof a.length === 'number' && a.length > 0) {\n    constructFromList.call(this, a); // [ {x,y} | bbox, {x,y} | bbox ...]\n  } else if (a === 'unit') {\n    constructUnitBox.call(this);\n  } else {\n    throw 'unexpected BoundingBox parameters';\n  }\n\n  function constructFromCoordinates(x1, y1, x2, y2) {\n    this.top = Math.min(y1, y2);\n    this.left = Math.min(x1, x2);\n    this.bottom = Math.max(y1, y2);\n    this.right = Math.max(x1, x2);\n  }\n\n  function constructUnitBox() {\n    this.top = 0;\n    this.left = 0;\n    this.bottom = 1;\n    this.right = 1;\n  }\n\n  function constructFromList(items) {\n    var item0 = items[0];\n    if (typeof item0.top === 'number') {\n      checkSpec(item0);\n      this.top = item0.top;\n      this.left = item0.left;\n      this.right = item0.right;\n      this.bottom = item0.bottom\n    } else {\n      this.top = this.bottom = item0.y;\n      this.left = this.right = item0.x;\n    }\n    for (var i = 1; i < items.length; ++i) {\n      var item = items[i];\n      if (typeof item.top === 'number') {\n        checkSpec(item);\n        this.left = Math.min(this.left, item.left);\n        this.right = Math.max(this.right, item.right);\n        this.top = Math.min(this.top, item.top);\n        this.bottom = Math.max(this.bottom, item.bottom);\n      } else {\n        this.left = Math.min(this.left, item.x);\n        this.right = Math.max(this.right, item.x);\n        this.top = Math.min(this.top, item.y);\n        this.bottom = Math.max(this.bottom, item.y);\n      }\n    }\n\n    function checkSpec(spec) {\n      if (spec.top > spec.bottom || spec.left > spec.right) {\n        throw 'invalid box: top > bottom or left > right';\n      }\n    }\n  }\n};\n\nmodule.exports = BoundingBox;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/bounding-box.js\n ** module id = 5\n ** module chunks = 0 1\n **/","'use strict';\n\nvar BoxTransformer = function(fromBox, toBox, options) {\n  this.fromBox = fromBox;\n  this.toBox = toBox;\n  this.x = x;\n  this.y = y;\n  this.options = {\n    center: true,\n    maintainAspectRatio: true\n  };\n  var self = this;\n  Object.keys(options || {}).forEach(function(option) {\n    self.options[option] = options[option];\n  });\n\n  var xInScale = this.fromBox.right - this.fromBox.left;\n  if (xInScale === 0) {\n    xInScale = 1\n  }\n  var yInScale = this.fromBox.bottom - this.fromBox.top;\n  if (yInScale === 0) {\n    yInScale = 1;\n  }\n  var xInAnchor = this.fromBox.left;\n  var yInAnchor = this.fromBox.top;\n\n  var xOutScale = this.toBox.right - this.toBox.left;\n  var yOutScale = this.toBox.bottom - this.toBox.top;\n  var xOutAnchor = this.toBox.left;\n  var yOutAnchor = this.toBox.top;\n\n  if (this.options.center) {\n    xInAnchor = 0.5 * (this.fromBox.left + this.fromBox.right);\n    yInAnchor = 0.5 * (this.fromBox.top + this.fromBox.bottom);\n    xOutAnchor = 0.5 * (this.toBox.left + this.toBox.right);\n    yOutAnchor = 0.5 * (this.toBox.top + this.toBox.bottom);\n  }\n\n  var xScale = xOutScale / xInScale;\n  var yScale = yOutScale / yInScale;\n  var minScale = Math.min(xScale, yScale);\n  if (this.options.maintainAspectRatio) {\n    xScale = minScale;\n    yScale = minScale;\n  }\n\n  function x(xIn) {\n    return (xIn - xInAnchor) * xScale + xOutAnchor;\n  }\n\n  function y(yIn) {\n    return (yIn - yInAnchor) * yScale + yOutAnchor;\n  }\n};\n\nmodule.exports = BoxTransformer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/box-transformer.js\n ** module id = 6\n ** module chunks = 0 1\n **/"],"sourceRoot":""}
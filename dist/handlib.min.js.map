{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///handlib.min.js","webpack:///webpack/bootstrap 4d09c3e8295b8ea406ec?cdd3","webpack:///./src/index.js?9552","webpack:///./src/glyph.js?f1d7","webpack:///./src/glyph-builder.js?9ff2","webpack:///./src/fx-glyph.js?a339","webpack:///./src/stroke.js?c9ce","webpack:///./src/bounding-box.js?370d","webpack:///./src/box-transformer.js?2ca9"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Glyph","GlyphBuilder","FXGlyph","BoundingBox","BoxTransformer","normalizeStrokes","strokesSpec","map","strokeSpec","stroke","i","length","push","x","y","spec","device","strokes","scale","strokeInProgress","prototype","Object","create","constructor","setDevice","addPoint","xy","self","lastPoint","endStroke","pop","getGlyph","Stroke","glyph","_glyph","_scale","bbox","_bbox","_getBBox","unitScaledStrokes","_unitScaledStrokes","getScaledStrokes","size","_sizes","_size","_getSize","sizes","_getSizes","subStrokes","_subStrokes","_getSubStrokes","signature","_signature","_getSignature","featureVector","_featureVector","_getFeatureVector","bboxes","bboxFrom","bboxTo","scaler","Math","min","right","left","bottom","top","oStrokes","points","reduce","tot","allSubStrokes","forEach","subStroke","type","join","fv","ssnf","sqrt","PC_DOT_COUNT","snf","pcDot","pcDots","distanceFrom","that","euclideanDistance","fv1","fv2","d2","d","getEqualSamples","xt","st","n","tmax","smax","isInLess","isInMore","xOut","isOut","s","sLE","sGE","sRange","xRange","x0","getPCDots","sDots","xIn","dot","yIn","nIn","sIn","si","yOut","_points","DS_UNIT_DEFAULT","_calculateSize","ds","_dS","_ds","_getDS","sList","_sList","_getSList","sStroke","_sStroke","_getSStroke","ds0","nIncrements","floor","nx","ny","dx","dy","xList","point","yList","nSamples","xs","ys","addSubStroke","strokePoints","startIndex","endIndex","increments","breakPoints","i1","i2","dot12","cosTheta","breakPointIndex","start","end","a","b","constructFromCoordinates","x1","y1","x2","y2","max","constructUnitBox","constructFromList","items","checkSpec","item0","item","undefined","arguments","fromBox","toBox","options","xInAnchor","xScale","xOutAnchor","yInAnchor","yScale","yOutAnchor","center","maintainAspectRatio","keys","option","xInScale","yInScale","xOutScale","yOutScale","minScale"],"mappings":"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","file":"handlib.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"handlib\"] = factory();\n\telse\n\t\troot[\"handlib\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"handlib\"] = factory();\n\telse\n\t\troot[\"handlib\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports.Glyph = __webpack_require__(1);\n\tmodule.exports.GlyphBuilder = __webpack_require__(2);\n\tmodule.exports.FXGlyph = __webpack_require__(3);\n\tmodule.exports.BoundingBox = __webpack_require__(5);\n\tmodule.exports.BoxTransformer = __webpack_require__(6);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar Glyph = function(spec) {\n\t  this.id = (spec && spec.id) || \"\";\n\t  this.device = (spec && spec.device) || \"\";\n\t  this.strokes = (spec && spec.strokes && normalizeStrokes(spec.strokes)) || [];\n\t  this.scale = spec && spec.scale;\n\t};\n\t\n\tfunction normalizeStrokes(strokesSpec) {\n\t  return strokesSpec.map(function(strokeSpec) {\n\t    if (typeof strokeSpec !== 'object') {\n\t      throw 'bad stroke spec: must be object';\n\t    }\n\t    if (typeof strokeSpec[0] === 'number') {\n\t      var stroke = [];\n\t      for (var i = 0; i < strokeSpec.length; i += 2) {\n\t        stroke.push({\n\t          x: strokeSpec[i],\n\t          y: strokeSpec[i + 1]\n\t        });\n\t      }\n\t      return stroke;\n\t    } else if (typeof strokeSpec[0] === 'object') {\n\t      return strokeSpec;\n\t    } else {\n\t      throw 'bad stroke spec: first must be number or (x,y) pair';\n\t    }\n\t  });\n\t}\n\t\n\tmodule.exports = Glyph;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Glyph = __webpack_require__(1);\n\t\n\tvar GlyphBuilder = function() {\n\t  Glyph.call(this);\n\t  this.strokeInProgress = false;\n\t};\n\t\n\tGlyphBuilder.prototype = Object.create(Glyph.prototype);\n\tGlyphBuilder.prototype.constructor = GlyphBuilder;\n\t\n\t// implementation -- methods\n\tGlyphBuilder.prototype.setDevice = function(device) {\n\t  this.device = device;\n\t};\n\t\n\tGlyphBuilder.prototype.addPoint = function(xy) {\n\t  var self = this;\n\t  if (!self.strokeInProgress) {\n\t    self.strokes.push([]);\n\t    self.strokeInProgress = true;\n\t  }\n\t\n\t  var stroke = self.strokes[self.strokes.length - 1];\n\t  if (stroke.length > 0) {\n\t    var lastPoint = stroke[stroke.length - 1];\n\t    if (lastPoint.x === xy.x && lastPoint.y === xy.y) {\n\t      return;\n\t    }\n\t  }\n\t\n\t  stroke.push(xy);\n\t};\n\t\n\tGlyphBuilder.prototype.endStroke = function() {\n\t  var self = this;\n\t  if (!self.strokeInProgress) {\n\t    return;\n\t  }\n\t  var stroke = self.strokes[self.strokes.length - 1];\n\t  if (stroke.length === 0) {\n\t    self.strokes.pop();\n\t  }\n\t  self.strokeInProgress = false;\n\t};\n\t\n\tGlyphBuilder.prototype.getGlyph = function() {\n\t  return new Glyph({\n\t    strokes: this.strokes,\n\t    device: this.device,\n\t  });\n\t};\n\t\n\tmodule.exports = GlyphBuilder;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* jshint jasmine: true */\n\t\n\tvar Stroke = __webpack_require__(4);\n\tvar BoundingBox = __webpack_require__(5);\n\tvar BoxTransformer = __webpack_require__(6);\n\t\n\tvar FXGlyph = function(glyph) {\n\t  if (!glyph.scale) {\n\t    throw 'glyph must have scale for successful feature extraction';\n\t  }\n\t  this._glyph = glyph;\n\t  this._scale = glyph.scale;\n\t};\n\t\n\t// getters\n\tFXGlyph.prototype = {\n\t  get glyph() {\n\t    return this._glyph;\n\t  },\n\t  get scale() {\n\t    return this._scale;\n\t  },\n\t  get id() {\n\t    return this._glyph.id;\n\t  },\n\t  get device() {\n\t    return this._glyph.device;\n\t  },\n\t  get bbox() {\n\t    if (!this._bbox) {\n\t      this._bbox = this._getBBox(this._glyph);\n\t    }\n\t    return this._bbox;\n\t  },\n\t  get strokes() {\n\t    return this._glyph.strokes;\n\t  },\n\t  get unitScaledStrokes() {\n\t    if (!this._unitScaledStrokes) {\n\t      this._unitScaledStrokes = FXGlyph.getScaledStrokes(this.strokes, this.bbox, new BoundingBox('unit'));\n\t    }\n\t    return this._unitScaledStrokes;\n\t  },\n\t  get size() {\n\t    if (!this._sizes) {\n\t      this._size = this._getSize();\n\t    }\n\t    return this._size;\n\t  },\n\t  get sizes() {\n\t    if (!this._sizes) {\n\t      this._sizes = this._getSizes();\n\t    }\n\t    return this._sizes;\n\t  },\n\t  get subStrokes() {\n\t    if (!this._subStrokes) {\n\t      this._subStrokes = this._getSubStrokes();\n\t    }\n\t    return this._subStrokes;\n\t  },\n\t  get signature() {\n\t    if (!this._signature) {\n\t      this._signature = this._getSignature();\n\t    }\n\t    return this._signature;\n\t  },\n\t  get featureVector() {\n\t    if (!this._featureVector) {\n\t      this._featureVector = this._getFeatureVector();\n\t    }\n\t    return this._featureVector;\n\t  }\n\t};\n\t\n\t// more methods\n\t\n\tFXGlyph.prototype._getBBox = function(glyph) {\n\t  var bboxes = glyph.strokes.map(function(stroke) {\n\t    return new BoundingBox(stroke);\n\t  });\n\t  return new BoundingBox(bboxes);\n\t};\n\t\n\tFXGlyph.getScaledStrokes = function(strokes, bboxFrom, bboxTo) {\n\t  var scaler = new BoxTransformer(bboxFrom, bboxTo);\n\t  var scale = Math.min(bboxTo.right - bboxTo.left, bboxTo.bottom - bboxTo.top);\n\t\n\t  var oStrokes = strokes.map(function(stroke) {\n\t    var points = stroke.map(function(xy) {\n\t      return {\n\t        x: scaler.x(xy.x),\n\t        y: scaler.y(xy.y)\n\t      };\n\t    });\n\t    return new Stroke(points, scale);\n\t  });\n\t  return oStrokes;\n\t};\n\t\n\tFXGlyph.prototype._getSizes = function() {\n\t  return this.unitScaledStrokes.map(function(stroke) {\n\t    return stroke.size;\n\t  });\n\t};\n\t\n\tFXGlyph.prototype._getSize = function() {\n\t  return this.sizes.reduce(function(tot, size) {\n\t    return tot + size;\n\t  }, 0);\n\t};\n\t\n\tFXGlyph.prototype._getSubStrokes = function() {\n\t  var allSubStrokes = [];\n\t  this.unitScaledStrokes.forEach(function(stroke) {\n\t    var subStrokes = stroke.subStrokes;\n\t    subStrokes.forEach(function(subStroke) {\n\t      allSubStrokes.push(subStroke);\n\t    });\n\t  });\n\t  return allSubStrokes;\n\t};\n\t\n\tFXGlyph.prototype._getSignature = function() {\n\t  return this.subStrokes.map(function(subStroke) {\n\t      return subStroke.type;\n\t    })\n\t    .join(':');\n\t};\n\t\n\tFXGlyph.prototype._getFeatureVector = function() {\n\t  var fv = [];\n\t  var ssnf = 1 / Math.sqrt(Stroke.PC_DOT_COUNT);\n\t  var snf = 1 / Math.sqrt(this.subStrokes.length);\n\t  this.subStrokes.forEach(function(subStroke) {\n\t    if (subStroke.type === 'mark') {\n\t      var pcDot = subStroke.pcDots[0];\n\t      fv.push(pcDot.x * snf);\n\t      fv.push(pcDot.y * snf);\n\t    } else {\n\t      subStroke.pcDots.forEach(function(pcDot) {\n\t        fv.push(pcDot.x * snf * ssnf);\n\t        fv.push(pcDot.y * snf * ssnf);\n\t      });\n\t    }\n\t  });\n\t  return fv;\n\t};\n\t\n\tFXGlyph.prototype.distanceFrom = function(that) {\n\t  return FXGlyph.euclideanDistance(this.featureVector, that.featureVector);\n\t};\n\t\n\tFXGlyph.euclideanDistance = function(fv1, fv2) {\n\t  if (fv1.length !== fv2.length) {\n\t    throw 'feature vectors must be same length';\n\t  }\n\t  var d2 = 0;\n\t  for (var i = 0; i < fv1.length; ++i) {\n\t    var d = fv1[i] - fv2[i];\n\t    d2 += d * d;\n\t  }\n\t  return Math.sqrt(d2);\n\t};\n\t\n\t// export\n\t\n\tmodule.exports = FXGlyph;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar Stroke = function(points, scale) {\n\t  this._points = points;\n\t  this._scale = scale;\n\t};\n\t\n\tStroke.DS_UNIT_DEFAULT = 0.05;\n\tStroke.PC_DOT_COUNT = 9;\n\t\n\tStroke.getEqualSamples = getEqualSamples;\n\t\n\t// getters\n\tStroke.prototype = {\n\t  get points() {\n\t    return this._points;\n\t  },\n\t  get scale() {\n\t    return this._scale;\n\t  },\n\t  get size() {\n\t    if (typeof this._size === 'undefined') {\n\t      this._size = this._calculateSize();\n\t    }\n\t    return this._size;\n\t  },\n\t  get ds() {\n\t    if (typeof this._dS === 'undefined') {\n\t      this._ds = this._getDS();\n\t    }\n\t    return this._ds;\n\t  },\n\t  get sList() {\n\t    if (typeof this._sList === 'undefined') {\n\t      this._sList = this._getSList();\n\t    }\n\t    return this._sList;\n\t  },\n\t  get sStroke() {\n\t    if (typeof this._sStroke === 'undefined') {\n\t      this._sStroke = this._getSStroke();\n\t    }\n\t    return this._sStroke;\n\t  },\n\t  get subStrokes() {\n\t    if (!this._subStrokes) {\n\t      this._subStrokes = this._getSubStrokes();\n\t    }\n\t    return this._subStrokes;\n\t  },\n\t};\n\t\n\tStroke.prototype._calculateSize = function() {\n\t  return this.sList[this.points.length - 1];\n\t};\n\t\n\tStroke.prototype._getDS = function() {\n\t  var ds0 = this.scale * Stroke.DS_UNIT_DEFAULT;\n\t  var nIncrements = Math.floor(this.size / ds0);\n\t  var ds = ds0;\n\t  if (nIncrements > 0) {\n\t    ds = this.size / nIncrements;\n\t  }\n\t  return ds;\n\t};\n\t\n\tStroke.prototype._getSList = function() {\n\t  var sList = [0];\n\t  var s = 0;\n\t  var x = this.points[0].x;\n\t  var y = this.points[0].y;\n\t  for (var i = 1; i < this.points.length; i++) {\n\t    var nx = this.points[i].x;\n\t    var ny = this.points[i].y;\n\t    var dx = nx - x;\n\t    var dy = ny - y;\n\t    var ds = Math.sqrt(dx * dx + dy * dy);\n\t    s += ds;\n\t    sList.push(s);\n\t    x = nx;\n\t    y = ny;\n\t  }\n\t  return sList;\n\t};\n\t\n\tStroke.prototype._getSStroke = function() {\n\t  var sList = this.sList;\n\t  var xList = this.points.map(function(point) {\n\t    return point.x;\n\t  });\n\t  var yList = this.points.map(function(point) {\n\t    return point.y;\n\t  });\n\t  var nSamples = 1 + Math.floor(this.size / this.ds + 0.1);\n\t  var xs = Stroke.getEqualSamples(xList, sList, nSamples);\n\t  var ys = Stroke.getEqualSamples(yList, sList, nSamples);\n\t  var stroke = [];\n\t  for (var i = 0; i < nSamples; i++) {\n\t    stroke.push({\n\t      x: xs[i],\n\t      y: ys[i]\n\t    });\n\t  }\n\t  return stroke;\n\t};\n\t\n\tStroke.prototype._getSubStrokes = function() {\n\t  if (this.sStroke.length <= 2) {\n\t    return [{\n\t      type: 'mark',\n\t      stroke: new Stroke([this.points[0]], this.scale),\n\t      pcDots: [this.points[0]],\n\t    }];\n\t  }\n\t\n\t  var increments = [];\n\t  var i;\n\t  for (i = 1; i < this.sStroke.length; i++) {\n\t    var dx = this.sStroke[i].x - this.sStroke[i - 1].x;\n\t    var dy = this.sStroke[i].y - this.sStroke[i - 1].y;\n\t    increments.push({\n\t      dx: dx,\n\t      dy: dy\n\t    });\n\t  }\n\t\n\t  var breakPoints = [];\n\t  for (i = 1; i < increments.length; i++) {\n\t    var i1 = increments[i - 1];\n\t    var i2 = increments[i];\n\t    var dot12 = i1.dx * i2.dx + i1.dy * i2.dy;\n\t    var cosTheta = dot12 / (this.ds * this.ds);\n\t    if (cosTheta < -0.1) {\n\t      breakPoints.push(i);\n\t    }\n\t  }\n\t  breakPoints.push(this.sStroke.length - 1);\n\t\n\t  var subStrokes = [];\n\t  var sizes = [];\n\t\n\t  function addSubStroke(strokePoints, startIndex, endIndex) {\n\t    var points = [];\n\t    for (var i = startIndex; i <= endIndex; i++) {\n\t      points.push(strokePoints[i]);\n\t    }\n\t    subStrokes.push(new Stroke(points, this.scale));\n\t    sizes.push(this.ds * (endIndex + 1 - startIndex));\n\t  }\n\t\n\t  var startIndex = 0;\n\t  var breakPointIndex = 0;\n\t  while (breakPointIndex < breakPoints.length) {\n\t    var endIndex = breakPoints[breakPointIndex];\n\t    addSubStroke.call(this, this.sStroke, startIndex, endIndex);\n\t    startIndex = endIndex;\n\t    breakPointIndex++;\n\t  }\n\t\n\t  return subStrokes.map(function(subStroke, i) {\n\t    var start = i === 0;\n\t    var end = i === subStrokes.length - 1;\n\t    var type = start && end ? 'stroke' :\n\t      start && !end ? 'start' :\n\t      !start && end ? 'end' :\n\t      'middle';\n\t    var pcDots = getPCDots(subStroke.points, sizes[i]);\n\t    return {\n\t      type: type,\n\t      stroke: subStroke,\n\t      pcDots: pcDots,\n\t    };\n\t  });\n\t};\n\t\n\tfunction getEqualSamples(xt, st, n) {\n\t  if (st.length != xt.length) {\n\t    throw 'st.length must equal xt.length';\n\t  }\n\t  if (st[0] !== 0) {\n\t    throw 'st[0] must be equal to zero';\n\t  }\n\t  for (var i = 1; i <= st.length; i++) {\n\t    if (st[i] < st[i - 1]) {\n\t      throw 'st must increase monotonically';\n\t    }\n\t  }\n\t  if (n <= 0 || typeof n !== 'number') {\n\t    throw 'n must be number > 0';\n\t  }\n\t  var tmax = xt.length;\n\t  var smax = st[tmax - 1];\n\t  var sIncrement = smax / (tmax - 1);\n\t  var isInLess = 0;\n\t  var isInMore = 0;\n\t  var xOut = [];\n\t  for (var isOut = 0; isOut < n; isOut++) {\n\t    var s = smax * (isOut / (n - 1));\n\t    while (st[isInMore] < s && isInMore < st.length - 1) {\n\t      isInMore += 1;\n\t    }\n\t    isInLess = isInMore;\n\t    while (st[isInLess] > s && isInLess > 0) {\n\t      isInLess -= 1;\n\t    }\n\t    var sLE = st[isInLess];\n\t    var sGE = st[isInMore];\n\t    if (sLE === sGE) {\n\t      xOut.push(xt[isInLess]);\n\t      continue;\n\t    }\n\t    var sRange = sGE - sLE;\n\t    var xRange = xt[isInMore] - xt[isInLess];\n\t    var x0 = xt[isInLess];\n\t    xOut.push(x0 + xRange * (s - sLE) / sRange);\n\t  }\n\t  return xOut;\n\t}\n\t\n\tfunction getPCDots(sDots, size) {\n\t  var xIn = sDots.map(function(dot) {\n\t    return dot.x;\n\t  });\n\t  var yIn = sDots.map(function(dot) {\n\t    return dot.y;\n\t  });\n\t  var nIn = sDots.length;\n\t  var sIn = [];\n\t  for (var si = 0; si < nIn; si++) {\n\t    sIn.push(size * si / (nIn - 1));\n\t  }\n\t\n\t  var xOut = getEqualSamples(xIn, sIn, Stroke.PC_DOT_COUNT);\n\t  var yOut = getEqualSamples(yIn, sIn, Stroke.PC_DOT_COUNT);\n\t\n\t  var pcDots = [];\n\t  for (var i = 0; i < Stroke.PC_DOT_COUNT; i++) {\n\t    pcDots.push({\n\t      x: xOut[i],\n\t      y: yOut[i]\n\t    });\n\t  }\n\t  return pcDots;\n\t}\n\t\n\t// export\n\t\n\tmodule.exports = Stroke;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar BoundingBox = function(a, b, c, d) {\n\t  this.top = undefined;\n\t  this.left = undefined;\n\t  this.bottom = undefined;\n\t  this.right = undefined;\n\t  if (typeof a === 'number' && typeof b === 'number' && typeof c === 'number' && typeof d === 'number') {\n\t    constructFromCoordinates.call(this, a, b, c, d); // x1, y1, x2, y2\n\t  } else if (typeof a === 'object' && typeof a.top === 'number') {\n\t    constructFromList.call(this, arguments); // args are series of BoundingBoxes or {top,left,bottom,right} specs\n\t  } else if (typeof a === 'object' && typeof a.length === 'number' && a.length > 0) {\n\t    constructFromList.call(this, a); // [ {x,y} | bbox, {x,y} | bbox ...]\n\t  } else if (a === 'unit') {\n\t    constructUnitBox.call(this);\n\t  } else {\n\t    throw 'unexpected BoundingBox parameters';\n\t  }\n\t\n\t  function constructFromCoordinates(x1, y1, x2, y2) {\n\t    this.top = Math.min(y1, y2);\n\t    this.left = Math.min(x1, x2);\n\t    this.bottom = Math.max(y1, y2);\n\t    this.right = Math.max(x1, x2);\n\t  }\n\t\n\t  function constructUnitBox() {\n\t    this.top = 0;\n\t    this.left = 0;\n\t    this.bottom = 1;\n\t    this.right = 1;\n\t  }\n\t\n\t  function constructFromList(items) {\n\t    var item0 = items[0];\n\t    if (typeof item0.top === 'number') {\n\t      checkSpec(item0);\n\t      this.top = item0.top;\n\t      this.left = item0.left;\n\t      this.right = item0.right;\n\t      this.bottom = item0.bottom\n\t    } else {\n\t      this.top = this.bottom = item0.y;\n\t      this.left = this.right = item0.x;\n\t    }\n\t    for (var i = 1; i < items.length; ++i) {\n\t      var item = items[i];\n\t      if (typeof item.top === 'number') {\n\t        checkSpec(item);\n\t        this.left = Math.min(this.left, item.left);\n\t        this.right = Math.max(this.right, item.right);\n\t        this.top = Math.min(this.top, item.top);\n\t        this.bottom = Math.max(this.bottom, item.bottom);\n\t      } else {\n\t        this.left = Math.min(this.left, item.x);\n\t        this.right = Math.max(this.right, item.x);\n\t        this.top = Math.min(this.top, item.y);\n\t        this.bottom = Math.max(this.bottom, item.y);\n\t      }\n\t    }\n\t\n\t    function checkSpec(spec) {\n\t      if (spec.top > spec.bottom || spec.left > spec.right) {\n\t        throw 'invalid box: top > bottom or left > right';\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tmodule.exports = BoundingBox;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar BoxTransformer = function(fromBox, toBox, options) {\n\t  this.fromBox = fromBox;\n\t  this.toBox = toBox;\n\t  this.x = x;\n\t  this.y = y;\n\t  this.options = {\n\t    center: true,\n\t    maintainAspectRatio: true\n\t  };\n\t  var self = this;\n\t  Object.keys(options || {}).forEach(function(option) {\n\t    self.options[option] = options[option];\n\t  });\n\t\n\t  var xInScale = this.fromBox.right - this.fromBox.left;\n\t  if (xInScale === 0) {\n\t    xInScale = 1\n\t  }\n\t  var yInScale = this.fromBox.bottom - this.fromBox.top;\n\t  if (yInScale === 0) {\n\t    yInScale = 1;\n\t  }\n\t  var xInAnchor = this.fromBox.left;\n\t  var yInAnchor = this.fromBox.top;\n\t\n\t  var xOutScale = this.toBox.right - this.toBox.left;\n\t  var yOutScale = this.toBox.bottom - this.toBox.top;\n\t  var xOutAnchor = this.toBox.left;\n\t  var yOutAnchor = this.toBox.top;\n\t\n\t  if (this.options.center) {\n\t    xInAnchor = 0.5 * (this.fromBox.left + this.fromBox.right);\n\t    yInAnchor = 0.5 * (this.fromBox.top + this.fromBox.bottom);\n\t    xOutAnchor = 0.5 * (this.toBox.left + this.toBox.right);\n\t    yOutAnchor = 0.5 * (this.toBox.top + this.toBox.bottom);\n\t  }\n\t\n\t  var xScale = xOutScale / xInScale;\n\t  var yScale = yOutScale / yInScale;\n\t  var minScale = Math.min(xScale, yScale);\n\t  if (this.options.maintainAspectRatio) {\n\t    xScale = minScale;\n\t    yScale = minScale;\n\t  }\n\t\n\t  function x(xIn) {\n\t    return (xIn - xInAnchor) * xScale + xOutAnchor;\n\t  }\n\t\n\t  function y(yIn) {\n\t    return (yIn - yInAnchor) * yScale + yOutAnchor;\n\t  }\n\t};\n\t\n\tmodule.exports = BoxTransformer;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** handlib.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4d09c3e8295b8ea406ec\n **/","'use strict';\n\nmodule.exports.Glyph = require('./glyph');\nmodule.exports.GlyphBuilder = require('./glyph-builder');\nmodule.exports.FXGlyph = require('./fx-glyph');\nmodule.exports.BoundingBox = require('./bounding-box');\nmodule.exports.BoxTransformer = require('./box-transformer');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0 1\n **/","'use strict';\n\nvar Glyph = function(spec) {\n  this.id = (spec && spec.id) || \"\";\n  this.device = (spec && spec.device) || \"\";\n  this.strokes = (spec && spec.strokes && normalizeStrokes(spec.strokes)) || [];\n  this.scale = spec && spec.scale;\n};\n\nfunction normalizeStrokes(strokesSpec) {\n  return strokesSpec.map(function(strokeSpec) {\n    if (typeof strokeSpec !== 'object') {\n      throw 'bad stroke spec: must be object';\n    }\n    if (typeof strokeSpec[0] === 'number') {\n      var stroke = [];\n      for (var i = 0; i < strokeSpec.length; i += 2) {\n        stroke.push({\n          x: strokeSpec[i],\n          y: strokeSpec[i + 1]\n        });\n      }\n      return stroke;\n    } else if (typeof strokeSpec[0] === 'object') {\n      return strokeSpec;\n    } else {\n      throw 'bad stroke spec: first must be number or (x,y) pair';\n    }\n  });\n}\n\nmodule.exports = Glyph;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/glyph.js\n ** module id = 1\n ** module chunks = 0 1\n **/","'use strict';\n\nvar Glyph = require('./glyph');\n\nvar GlyphBuilder = function() {\n  Glyph.call(this);\n  this.strokeInProgress = false;\n};\n\nGlyphBuilder.prototype = Object.create(Glyph.prototype);\nGlyphBuilder.prototype.constructor = GlyphBuilder;\n\n// implementation -- methods\nGlyphBuilder.prototype.setDevice = function(device) {\n  this.device = device;\n};\n\nGlyphBuilder.prototype.addPoint = function(xy) {\n  var self = this;\n  if (!self.strokeInProgress) {\n    self.strokes.push([]);\n    self.strokeInProgress = true;\n  }\n\n  var stroke = self.strokes[self.strokes.length - 1];\n  if (stroke.length > 0) {\n    var lastPoint = stroke[stroke.length - 1];\n    if (lastPoint.x === xy.x && lastPoint.y === xy.y) {\n      return;\n    }\n  }\n\n  stroke.push(xy);\n};\n\nGlyphBuilder.prototype.endStroke = function() {\n  var self = this;\n  if (!self.strokeInProgress) {\n    return;\n  }\n  var stroke = self.strokes[self.strokes.length - 1];\n  if (stroke.length === 0) {\n    self.strokes.pop();\n  }\n  self.strokeInProgress = false;\n};\n\nGlyphBuilder.prototype.getGlyph = function() {\n  return new Glyph({\n    strokes: this.strokes,\n    device: this.device,\n  });\n};\n\nmodule.exports = GlyphBuilder;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/glyph-builder.js\n ** module id = 2\n ** module chunks = 0 1\n **/","'use strict';\n\n/* jshint jasmine: true */\n\nvar Stroke = require('./stroke');\nvar BoundingBox = require('./bounding-box');\nvar BoxTransformer = require('./box-transformer');\n\nvar FXGlyph = function(glyph) {\n  if (!glyph.scale) {\n    throw 'glyph must have scale for successful feature extraction';\n  }\n  this._glyph = glyph;\n  this._scale = glyph.scale;\n};\n\n// getters\nFXGlyph.prototype = {\n  get glyph() {\n    return this._glyph;\n  },\n  get scale() {\n    return this._scale;\n  },\n  get id() {\n    return this._glyph.id;\n  },\n  get device() {\n    return this._glyph.device;\n  },\n  get bbox() {\n    if (!this._bbox) {\n      this._bbox = this._getBBox(this._glyph);\n    }\n    return this._bbox;\n  },\n  get strokes() {\n    return this._glyph.strokes;\n  },\n  get unitScaledStrokes() {\n    if (!this._unitScaledStrokes) {\n      this._unitScaledStrokes = FXGlyph.getScaledStrokes(this.strokes, this.bbox, new BoundingBox('unit'));\n    }\n    return this._unitScaledStrokes;\n  },\n  get size() {\n    if (!this._sizes) {\n      this._size = this._getSize();\n    }\n    return this._size;\n  },\n  get sizes() {\n    if (!this._sizes) {\n      this._sizes = this._getSizes();\n    }\n    return this._sizes;\n  },\n  get subStrokes() {\n    if (!this._subStrokes) {\n      this._subStrokes = this._getSubStrokes();\n    }\n    return this._subStrokes;\n  },\n  get signature() {\n    if (!this._signature) {\n      this._signature = this._getSignature();\n    }\n    return this._signature;\n  },\n  get featureVector() {\n    if (!this._featureVector) {\n      this._featureVector = this._getFeatureVector();\n    }\n    return this._featureVector;\n  }\n};\n\n// more methods\n\nFXGlyph.prototype._getBBox = function(glyph) {\n  var bboxes = glyph.strokes.map(function(stroke) {\n    return new BoundingBox(stroke);\n  });\n  return new BoundingBox(bboxes);\n};\n\nFXGlyph.getScaledStrokes = function(strokes, bboxFrom, bboxTo) {\n  var scaler = new BoxTransformer(bboxFrom, bboxTo);\n  var scale = Math.min(bboxTo.right - bboxTo.left, bboxTo.bottom - bboxTo.top);\n\n  var oStrokes = strokes.map(function(stroke) {\n    var points = stroke.map(function(xy) {\n      return {\n        x: scaler.x(xy.x),\n        y: scaler.y(xy.y)\n      };\n    });\n    return new Stroke(points, scale);\n  });\n  return oStrokes;\n};\n\nFXGlyph.prototype._getSizes = function() {\n  return this.unitScaledStrokes.map(function(stroke) {\n    return stroke.size;\n  });\n};\n\nFXGlyph.prototype._getSize = function() {\n  return this.sizes.reduce(function(tot, size) {\n    return tot + size;\n  }, 0);\n};\n\nFXGlyph.prototype._getSubStrokes = function() {\n  var allSubStrokes = [];\n  this.unitScaledStrokes.forEach(function(stroke) {\n    var subStrokes = stroke.subStrokes;\n    subStrokes.forEach(function(subStroke) {\n      allSubStrokes.push(subStroke);\n    });\n  });\n  return allSubStrokes;\n};\n\nFXGlyph.prototype._getSignature = function() {\n  return this.subStrokes.map(function(subStroke) {\n      return subStroke.type;\n    })\n    .join(':');\n};\n\nFXGlyph.prototype._getFeatureVector = function() {\n  var fv = [];\n  var ssnf = 1 / Math.sqrt(Stroke.PC_DOT_COUNT);\n  var snf = 1 / Math.sqrt(this.subStrokes.length);\n  this.subStrokes.forEach(function(subStroke) {\n    if (subStroke.type === 'mark') {\n      var pcDot = subStroke.pcDots[0];\n      fv.push(pcDot.x * snf);\n      fv.push(pcDot.y * snf);\n    } else {\n      subStroke.pcDots.forEach(function(pcDot) {\n        fv.push(pcDot.x * snf * ssnf);\n        fv.push(pcDot.y * snf * ssnf);\n      });\n    }\n  });\n  return fv;\n};\n\nFXGlyph.prototype.distanceFrom = function(that) {\n  return FXGlyph.euclideanDistance(this.featureVector, that.featureVector);\n};\n\nFXGlyph.euclideanDistance = function(fv1, fv2) {\n  if (fv1.length !== fv2.length) {\n    throw 'feature vectors must be same length';\n  }\n  var d2 = 0;\n  for (var i = 0; i < fv1.length; ++i) {\n    var d = fv1[i] - fv2[i];\n    d2 += d * d;\n  }\n  return Math.sqrt(d2);\n};\n\n// export\n\nmodule.exports = FXGlyph;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/fx-glyph.js\n ** module id = 3\n ** module chunks = 0 1\n **/","'use strict';\n\nvar Stroke = function(points, scale) {\n  this._points = points;\n  this._scale = scale;\n};\n\nStroke.DS_UNIT_DEFAULT = 0.05;\nStroke.PC_DOT_COUNT = 9;\n\nStroke.getEqualSamples = getEqualSamples;\n\n// getters\nStroke.prototype = {\n  get points() {\n    return this._points;\n  },\n  get scale() {\n    return this._scale;\n  },\n  get size() {\n    if (typeof this._size === 'undefined') {\n      this._size = this._calculateSize();\n    }\n    return this._size;\n  },\n  get ds() {\n    if (typeof this._dS === 'undefined') {\n      this._ds = this._getDS();\n    }\n    return this._ds;\n  },\n  get sList() {\n    if (typeof this._sList === 'undefined') {\n      this._sList = this._getSList();\n    }\n    return this._sList;\n  },\n  get sStroke() {\n    if (typeof this._sStroke === 'undefined') {\n      this._sStroke = this._getSStroke();\n    }\n    return this._sStroke;\n  },\n  get subStrokes() {\n    if (!this._subStrokes) {\n      this._subStrokes = this._getSubStrokes();\n    }\n    return this._subStrokes;\n  },\n};\n\nStroke.prototype._calculateSize = function() {\n  return this.sList[this.points.length - 1];\n};\n\nStroke.prototype._getDS = function() {\n  var ds0 = this.scale * Stroke.DS_UNIT_DEFAULT;\n  var nIncrements = Math.floor(this.size / ds0);\n  var ds = ds0;\n  if (nIncrements > 0) {\n    ds = this.size / nIncrements;\n  }\n  return ds;\n};\n\nStroke.prototype._getSList = function() {\n  var sList = [0];\n  var s = 0;\n  var x = this.points[0].x;\n  var y = this.points[0].y;\n  for (var i = 1; i < this.points.length; i++) {\n    var nx = this.points[i].x;\n    var ny = this.points[i].y;\n    var dx = nx - x;\n    var dy = ny - y;\n    var ds = Math.sqrt(dx * dx + dy * dy);\n    s += ds;\n    sList.push(s);\n    x = nx;\n    y = ny;\n  }\n  return sList;\n};\n\nStroke.prototype._getSStroke = function() {\n  var sList = this.sList;\n  var xList = this.points.map(function(point) {\n    return point.x;\n  });\n  var yList = this.points.map(function(point) {\n    return point.y;\n  });\n  var nSamples = 1 + Math.floor(this.size / this.ds + 0.1);\n  var xs = Stroke.getEqualSamples(xList, sList, nSamples);\n  var ys = Stroke.getEqualSamples(yList, sList, nSamples);\n  var stroke = [];\n  for (var i = 0; i < nSamples; i++) {\n    stroke.push({\n      x: xs[i],\n      y: ys[i]\n    });\n  }\n  return stroke;\n};\n\nStroke.prototype._getSubStrokes = function() {\n  if (this.sStroke.length <= 2) {\n    return [{\n      type: 'mark',\n      stroke: new Stroke([this.points[0]], this.scale),\n      pcDots: [this.points[0]],\n    }];\n  }\n\n  var increments = [];\n  var i;\n  for (i = 1; i < this.sStroke.length; i++) {\n    var dx = this.sStroke[i].x - this.sStroke[i - 1].x;\n    var dy = this.sStroke[i].y - this.sStroke[i - 1].y;\n    increments.push({\n      dx: dx,\n      dy: dy\n    });\n  }\n\n  var breakPoints = [];\n  for (i = 1; i < increments.length; i++) {\n    var i1 = increments[i - 1];\n    var i2 = increments[i];\n    var dot12 = i1.dx * i2.dx + i1.dy * i2.dy;\n    var cosTheta = dot12 / (this.ds * this.ds);\n    if (cosTheta < -0.1) {\n      breakPoints.push(i);\n    }\n  }\n  breakPoints.push(this.sStroke.length - 1);\n\n  var subStrokes = [];\n  var sizes = [];\n\n  function addSubStroke(strokePoints, startIndex, endIndex) {\n    var points = [];\n    for (var i = startIndex; i <= endIndex; i++) {\n      points.push(strokePoints[i]);\n    }\n    subStrokes.push(new Stroke(points, this.scale));\n    sizes.push(this.ds * (endIndex + 1 - startIndex));\n  }\n\n  var startIndex = 0;\n  var breakPointIndex = 0;\n  while (breakPointIndex < breakPoints.length) {\n    var endIndex = breakPoints[breakPointIndex];\n    addSubStroke.call(this, this.sStroke, startIndex, endIndex);\n    startIndex = endIndex;\n    breakPointIndex++;\n  }\n\n  return subStrokes.map(function(subStroke, i) {\n    var start = i === 0;\n    var end = i === subStrokes.length - 1;\n    var type = start && end ? 'stroke' :\n      start && !end ? 'start' :\n      !start && end ? 'end' :\n      'middle';\n    var pcDots = getPCDots(subStroke.points, sizes[i]);\n    return {\n      type: type,\n      stroke: subStroke,\n      pcDots: pcDots,\n    };\n  });\n};\n\nfunction getEqualSamples(xt, st, n) {\n  if (st.length != xt.length) {\n    throw 'st.length must equal xt.length';\n  }\n  if (st[0] !== 0) {\n    throw 'st[0] must be equal to zero';\n  }\n  for (var i = 1; i <= st.length; i++) {\n    if (st[i] < st[i - 1]) {\n      throw 'st must increase monotonically';\n    }\n  }\n  if (n <= 0 || typeof n !== 'number') {\n    throw 'n must be number > 0';\n  }\n  var tmax = xt.length;\n  var smax = st[tmax - 1];\n  var sIncrement = smax / (tmax - 1);\n  var isInLess = 0;\n  var isInMore = 0;\n  var xOut = [];\n  for (var isOut = 0; isOut < n; isOut++) {\n    var s = smax * (isOut / (n - 1));\n    while (st[isInMore] < s && isInMore < st.length - 1) {\n      isInMore += 1;\n    }\n    isInLess = isInMore;\n    while (st[isInLess] > s && isInLess > 0) {\n      isInLess -= 1;\n    }\n    var sLE = st[isInLess];\n    var sGE = st[isInMore];\n    if (sLE === sGE) {\n      xOut.push(xt[isInLess]);\n      continue;\n    }\n    var sRange = sGE - sLE;\n    var xRange = xt[isInMore] - xt[isInLess];\n    var x0 = xt[isInLess];\n    xOut.push(x0 + xRange * (s - sLE) / sRange);\n  }\n  return xOut;\n}\n\nfunction getPCDots(sDots, size) {\n  var xIn = sDots.map(function(dot) {\n    return dot.x;\n  });\n  var yIn = sDots.map(function(dot) {\n    return dot.y;\n  });\n  var nIn = sDots.length;\n  var sIn = [];\n  for (var si = 0; si < nIn; si++) {\n    sIn.push(size * si / (nIn - 1));\n  }\n\n  var xOut = getEqualSamples(xIn, sIn, Stroke.PC_DOT_COUNT);\n  var yOut = getEqualSamples(yIn, sIn, Stroke.PC_DOT_COUNT);\n\n  var pcDots = [];\n  for (var i = 0; i < Stroke.PC_DOT_COUNT; i++) {\n    pcDots.push({\n      x: xOut[i],\n      y: yOut[i]\n    });\n  }\n  return pcDots;\n}\n\n// export\n\nmodule.exports = Stroke;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/stroke.js\n ** module id = 4\n ** module chunks = 0 1\n **/","'use strict';\n\nvar BoundingBox = function(a, b, c, d) {\n  this.top = undefined;\n  this.left = undefined;\n  this.bottom = undefined;\n  this.right = undefined;\n  if (typeof a === 'number' && typeof b === 'number' && typeof c === 'number' && typeof d === 'number') {\n    constructFromCoordinates.call(this, a, b, c, d); // x1, y1, x2, y2\n  } else if (typeof a === 'object' && typeof a.top === 'number') {\n    constructFromList.call(this, arguments); // args are series of BoundingBoxes or {top,left,bottom,right} specs\n  } else if (typeof a === 'object' && typeof a.length === 'number' && a.length > 0) {\n    constructFromList.call(this, a); // [ {x,y} | bbox, {x,y} | bbox ...]\n  } else if (a === 'unit') {\n    constructUnitBox.call(this);\n  } else {\n    throw 'unexpected BoundingBox parameters';\n  }\n\n  function constructFromCoordinates(x1, y1, x2, y2) {\n    this.top = Math.min(y1, y2);\n    this.left = Math.min(x1, x2);\n    this.bottom = Math.max(y1, y2);\n    this.right = Math.max(x1, x2);\n  }\n\n  function constructUnitBox() {\n    this.top = 0;\n    this.left = 0;\n    this.bottom = 1;\n    this.right = 1;\n  }\n\n  function constructFromList(items) {\n    var item0 = items[0];\n    if (typeof item0.top === 'number') {\n      checkSpec(item0);\n      this.top = item0.top;\n      this.left = item0.left;\n      this.right = item0.right;\n      this.bottom = item0.bottom\n    } else {\n      this.top = this.bottom = item0.y;\n      this.left = this.right = item0.x;\n    }\n    for (var i = 1; i < items.length; ++i) {\n      var item = items[i];\n      if (typeof item.top === 'number') {\n        checkSpec(item);\n        this.left = Math.min(this.left, item.left);\n        this.right = Math.max(this.right, item.right);\n        this.top = Math.min(this.top, item.top);\n        this.bottom = Math.max(this.bottom, item.bottom);\n      } else {\n        this.left = Math.min(this.left, item.x);\n        this.right = Math.max(this.right, item.x);\n        this.top = Math.min(this.top, item.y);\n        this.bottom = Math.max(this.bottom, item.y);\n      }\n    }\n\n    function checkSpec(spec) {\n      if (spec.top > spec.bottom || spec.left > spec.right) {\n        throw 'invalid box: top > bottom or left > right';\n      }\n    }\n  }\n};\n\nmodule.exports = BoundingBox;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/bounding-box.js\n ** module id = 5\n ** module chunks = 0 1\n **/","'use strict';\n\nvar BoxTransformer = function(fromBox, toBox, options) {\n  this.fromBox = fromBox;\n  this.toBox = toBox;\n  this.x = x;\n  this.y = y;\n  this.options = {\n    center: true,\n    maintainAspectRatio: true\n  };\n  var self = this;\n  Object.keys(options || {}).forEach(function(option) {\n    self.options[option] = options[option];\n  });\n\n  var xInScale = this.fromBox.right - this.fromBox.left;\n  if (xInScale === 0) {\n    xInScale = 1\n  }\n  var yInScale = this.fromBox.bottom - this.fromBox.top;\n  if (yInScale === 0) {\n    yInScale = 1;\n  }\n  var xInAnchor = this.fromBox.left;\n  var yInAnchor = this.fromBox.top;\n\n  var xOutScale = this.toBox.right - this.toBox.left;\n  var yOutScale = this.toBox.bottom - this.toBox.top;\n  var xOutAnchor = this.toBox.left;\n  var yOutAnchor = this.toBox.top;\n\n  if (this.options.center) {\n    xInAnchor = 0.5 * (this.fromBox.left + this.fromBox.right);\n    yInAnchor = 0.5 * (this.fromBox.top + this.fromBox.bottom);\n    xOutAnchor = 0.5 * (this.toBox.left + this.toBox.right);\n    yOutAnchor = 0.5 * (this.toBox.top + this.toBox.bottom);\n  }\n\n  var xScale = xOutScale / xInScale;\n  var yScale = yOutScale / yInScale;\n  var minScale = Math.min(xScale, yScale);\n  if (this.options.maintainAspectRatio) {\n    xScale = minScale;\n    yScale = minScale;\n  }\n\n  function x(xIn) {\n    return (xIn - xInAnchor) * xScale + xOutAnchor;\n  }\n\n  function y(yIn) {\n    return (yIn - yInAnchor) * yScale + yOutAnchor;\n  }\n};\n\nmodule.exports = BoxTransformer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/box-transformer.js\n ** module id = 6\n ** module chunks = 0 1\n **/"],"sourceRoot":""}